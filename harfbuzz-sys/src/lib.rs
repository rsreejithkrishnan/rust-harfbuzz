#![allow(non_camel_case_types)]

#[cfg(any(target_os = "android", all(unix, not(target_os = "macos"))))]
extern crate freetype;

extern crate libc;

#[cfg(any(target_os = "android", all(unix, not(target_os = "macos"))))]
extern "C" {
    pub fn hb_ft_font_create_referenced(face: freetype::freetype::FT_Face) -> *mut hb_font_t;
}

/* automatically generated by rust-bindgen */

pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const HB_UNICODE_MAX_DECOMPOSITION_LEN: ::std::os::raw::c_uint = 19;
pub const HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT: ::std::os::raw::c_uint =
    65533;
pub const HB_VERSION_MAJOR: ::std::os::raw::c_uint = 1;
pub const HB_VERSION_MINOR: ::std::os::raw::c_uint = 6;
pub const HB_VERSION_MICRO: ::std::os::raw::c_uint = 0;
pub const HB_VERSION_STRING: &'static [u8; 6usize] = b"1.6.0\x00";
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type hb_bool_t = ::std::os::raw::c_int;
pub type hb_codepoint_t = u32;
pub type hb_position_t = i32;
pub type hb_mask_t = u32;
#[repr(C)]
#[derive(Copy)]
pub union _hb_var_int_t {
    pub u32: u32,
    pub i32: i32,
    pub u16: [u16; 2usize],
    pub i16: [i16; 2usize],
    pub u8: [u8; 4usize],
    pub i8: [i8; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__hb_var_int_t() {
    assert_eq!(::std::mem::size_of::<_hb_var_int_t>() , 4usize , concat ! (
               "Size of: " , stringify ! ( _hb_var_int_t ) ));
    assert_eq! (::std::mem::align_of::<_hb_var_int_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( _hb_var_int_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _hb_var_int_t ) ) . u32 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _hb_var_int_t ) , "::"
                , stringify ! ( u32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _hb_var_int_t ) ) . i32 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _hb_var_int_t ) , "::"
                , stringify ! ( i32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _hb_var_int_t ) ) . u16 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _hb_var_int_t ) , "::"
                , stringify ! ( u16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _hb_var_int_t ) ) . i16 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _hb_var_int_t ) , "::"
                , stringify ! ( i16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _hb_var_int_t ) ) . u8 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _hb_var_int_t ) , "::"
                , stringify ! ( u8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _hb_var_int_t ) ) . i8 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _hb_var_int_t ) , "::"
                , stringify ! ( i8 ) ));
}
impl Clone for _hb_var_int_t {
    fn clone(&self) -> Self { *self }
}
pub type hb_var_int_t = _hb_var_int_t;
pub type hb_tag_t = u32;
extern "C" {
    pub fn hb_tag_from_string(str: *const ::std::os::raw::c_char,
                              len: ::std::os::raw::c_int) -> hb_tag_t;
}
extern "C" {
    pub fn hb_tag_to_string(tag: hb_tag_t, buf: *mut ::std::os::raw::c_char);
}
#[repr(u32)]
/// hb_direction_t:
/// @HB_DIRECTION_INVALID: Initial, unset direction.
/// @HB_DIRECTION_LTR: Text is set horizontally from left to right.
/// @HB_DIRECTION_RTL: Text is set horizontally from right to left.
/// @HB_DIRECTION_TTB: Text is set vertically from top to bottom.
/// @HB_DIRECTION_BTT: Text is set vertically from bottom to top.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_direction_t {
    HB_DIRECTION_INVALID = 0,
    HB_DIRECTION_LTR = 4,
    HB_DIRECTION_RTL = 5,
    HB_DIRECTION_TTB = 6,
    HB_DIRECTION_BTT = 7,
}
extern "C" {
    pub fn hb_direction_from_string(str: *const ::std::os::raw::c_char,
                                    len: ::std::os::raw::c_int)
     -> hb_direction_t;
}
extern "C" {
    pub fn hb_direction_to_string(direction: hb_direction_t)
     -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_language_impl_t {
    _unused: [u8; 0],
}
pub type hb_language_t = *const hb_language_impl_t;
extern "C" {
    pub fn hb_language_from_string(str: *const ::std::os::raw::c_char,
                                   len: ::std::os::raw::c_int)
     -> hb_language_t;
}
extern "C" {
    pub fn hb_language_to_string(language: hb_language_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_language_get_default() -> hb_language_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_script_t {
    HB_SCRIPT_COMMON = 1517910393,
    HB_SCRIPT_INHERITED = 1516858984,
    HB_SCRIPT_UNKNOWN = 1517976186,
    HB_SCRIPT_ARABIC = 1098015074,
    HB_SCRIPT_ARMENIAN = 1098018158,
    HB_SCRIPT_BENGALI = 1113943655,
    HB_SCRIPT_CYRILLIC = 1132032620,
    HB_SCRIPT_DEVANAGARI = 1147500129,
    HB_SCRIPT_GEORGIAN = 1197830002,
    HB_SCRIPT_GREEK = 1198679403,
    HB_SCRIPT_GUJARATI = 1198877298,
    HB_SCRIPT_GURMUKHI = 1198879349,
    HB_SCRIPT_HANGUL = 1214344807,
    HB_SCRIPT_HAN = 1214344809,
    HB_SCRIPT_HEBREW = 1214603890,
    HB_SCRIPT_HIRAGANA = 1214870113,
    HB_SCRIPT_KANNADA = 1265525857,
    HB_SCRIPT_KATAKANA = 1264676449,
    HB_SCRIPT_LAO = 1281453935,
    HB_SCRIPT_LATIN = 1281455214,
    HB_SCRIPT_MALAYALAM = 1298954605,
    HB_SCRIPT_ORIYA = 1332902241,
    HB_SCRIPT_TAMIL = 1415671148,
    HB_SCRIPT_TELUGU = 1415933045,
    HB_SCRIPT_THAI = 1416126825,
    HB_SCRIPT_TIBETAN = 1416192628,
    HB_SCRIPT_BOPOMOFO = 1114599535,
    HB_SCRIPT_BRAILLE = 1114792297,
    HB_SCRIPT_CANADIAN_SYLLABICS = 1130458739,
    HB_SCRIPT_CHEROKEE = 1130915186,
    HB_SCRIPT_ETHIOPIC = 1165256809,
    HB_SCRIPT_KHMER = 1265134962,
    HB_SCRIPT_MONGOLIAN = 1299148391,
    HB_SCRIPT_MYANMAR = 1299803506,
    HB_SCRIPT_OGHAM = 1332175213,
    HB_SCRIPT_RUNIC = 1383427698,
    HB_SCRIPT_SINHALA = 1399418472,
    HB_SCRIPT_SYRIAC = 1400468067,
    HB_SCRIPT_THAANA = 1416126817,
    HB_SCRIPT_YI = 1500080489,
    HB_SCRIPT_DESERET = 1148416628,
    HB_SCRIPT_GOTHIC = 1198486632,
    HB_SCRIPT_OLD_ITALIC = 1232363884,
    HB_SCRIPT_BUHID = 1114990692,
    HB_SCRIPT_HANUNOO = 1214344815,
    HB_SCRIPT_TAGALOG = 1416064103,
    HB_SCRIPT_TAGBANWA = 1415669602,
    HB_SCRIPT_CYPRIOT = 1131442804,
    HB_SCRIPT_LIMBU = 1281977698,
    HB_SCRIPT_LINEAR_B = 1281977954,
    HB_SCRIPT_OSMANYA = 1332964705,
    HB_SCRIPT_SHAVIAN = 1399349623,
    HB_SCRIPT_TAI_LE = 1415670885,
    HB_SCRIPT_UGARITIC = 1432838514,
    HB_SCRIPT_BUGINESE = 1114990441,
    HB_SCRIPT_COPTIC = 1131376756,
    HB_SCRIPT_GLAGOLITIC = 1198285159,
    HB_SCRIPT_KHAROSHTHI = 1265131890,
    HB_SCRIPT_NEW_TAI_LUE = 1415670901,
    HB_SCRIPT_OLD_PERSIAN = 1483761007,
    HB_SCRIPT_SYLOTI_NAGRI = 1400466543,
    HB_SCRIPT_TIFINAGH = 1415999079,
    HB_SCRIPT_BALINESE = 1113681001,
    HB_SCRIPT_CUNEIFORM = 1483961720,
    HB_SCRIPT_NKO = 1315663727,
    HB_SCRIPT_PHAGS_PA = 1349017959,
    HB_SCRIPT_PHOENICIAN = 1349021304,
    HB_SCRIPT_CARIAN = 1130459753,
    HB_SCRIPT_CHAM = 1130914157,
    HB_SCRIPT_KAYAH_LI = 1264675945,
    HB_SCRIPT_LEPCHA = 1281716323,
    HB_SCRIPT_LYCIAN = 1283023721,
    HB_SCRIPT_LYDIAN = 1283023977,
    HB_SCRIPT_OL_CHIKI = 1332503403,
    HB_SCRIPT_REJANG = 1382706791,
    HB_SCRIPT_SAURASHTRA = 1398895986,
    HB_SCRIPT_SUNDANESE = 1400204900,
    HB_SCRIPT_VAI = 1449224553,
    HB_SCRIPT_AVESTAN = 1098281844,
    HB_SCRIPT_BAMUM = 1113681269,
    HB_SCRIPT_EGYPTIAN_HIEROGLYPHS = 1164409200,
    HB_SCRIPT_IMPERIAL_ARAMAIC = 1098018153,
    HB_SCRIPT_INSCRIPTIONAL_PAHLAVI = 1349020777,
    HB_SCRIPT_INSCRIPTIONAL_PARTHIAN = 1349678185,
    HB_SCRIPT_JAVANESE = 1247901281,
    HB_SCRIPT_KAITHI = 1265920105,
    HB_SCRIPT_LISU = 1281979253,
    HB_SCRIPT_MEETEI_MAYEK = 1299473769,
    HB_SCRIPT_OLD_SOUTH_ARABIAN = 1398895202,
    HB_SCRIPT_OLD_TURKIC = 1332898664,
    HB_SCRIPT_SAMARITAN = 1398893938,
    HB_SCRIPT_TAI_THAM = 1281453665,
    HB_SCRIPT_TAI_VIET = 1415673460,
    HB_SCRIPT_BATAK = 1113683051,
    HB_SCRIPT_BRAHMI = 1114792296,
    HB_SCRIPT_MANDAIC = 1298230884,
    HB_SCRIPT_CHAKMA = 1130457965,
    HB_SCRIPT_MEROITIC_CURSIVE = 1298494051,
    HB_SCRIPT_MEROITIC_HIEROGLYPHS = 1298494063,
    HB_SCRIPT_MIAO = 1349284452,
    HB_SCRIPT_SHARADA = 1399353956,
    HB_SCRIPT_SORA_SOMPENG = 1399812705,
    HB_SCRIPT_TAKRI = 1415670642,
    HB_SCRIPT_BASSA_VAH = 1113682803,
    HB_SCRIPT_CAUCASIAN_ALBANIAN = 1097295970,
    HB_SCRIPT_DUPLOYAN = 1148547180,
    HB_SCRIPT_ELBASAN = 1164730977,
    HB_SCRIPT_GRANTHA = 1198678382,
    HB_SCRIPT_KHOJKI = 1265135466,
    HB_SCRIPT_KHUDAWADI = 1399418468,
    HB_SCRIPT_LINEAR_A = 1281977953,
    HB_SCRIPT_MAHAJANI = 1298229354,
    HB_SCRIPT_MANICHAEAN = 1298230889,
    HB_SCRIPT_MENDE_KIKAKUI = 1298493028,
    HB_SCRIPT_MODI = 1299145833,
    HB_SCRIPT_MRO = 1299345263,
    HB_SCRIPT_NABATAEAN = 1315070324,
    HB_SCRIPT_OLD_NORTH_ARABIAN = 1315009122,
    HB_SCRIPT_OLD_PERMIC = 1348825709,
    HB_SCRIPT_PAHAWH_HMONG = 1215131239,
    HB_SCRIPT_PALMYRENE = 1348562029,
    HB_SCRIPT_PAU_CIN_HAU = 1348564323,
    HB_SCRIPT_PSALTER_PAHLAVI = 1349020784,
    HB_SCRIPT_SIDDHAM = 1399415908,
    HB_SCRIPT_TIRHUTA = 1416196712,
    HB_SCRIPT_WARANG_CITI = 1466004065,
    HB_SCRIPT_AHOM = 1097363309,
    HB_SCRIPT_ANATOLIAN_HIEROGLYPHS = 1215067511,
    HB_SCRIPT_HATRAN = 1214346354,
    HB_SCRIPT_MULTANI = 1299541108,
    HB_SCRIPT_OLD_HUNGARIAN = 1215655527,
    HB_SCRIPT_SIGNWRITING = 1399287415,
    HB_SCRIPT_ADLAM = 1097100397,
    HB_SCRIPT_BHAIKSUKI = 1114139507,
    HB_SCRIPT_MARCHEN = 1298231907,
    HB_SCRIPT_OSAGE = 1332963173,
    HB_SCRIPT_TANGUT = 1415671399,
    HB_SCRIPT_NEWA = 1315272545,
    HB_SCRIPT_MASARAM_GONDI = 1198485101,
    HB_SCRIPT_NUSHU = 1316186229,
    HB_SCRIPT_SOYOMBO = 1399814511,
    HB_SCRIPT_ZANABAZAR_SQUARE = 1516334690,
    HB_SCRIPT_INVALID = 0,
    _HB_SCRIPT_MAX_VALUE = 4294967295,
    _HB_SCRIPT_MAX_VALUE_SIGNED = 2147483647,
}
extern "C" {
    pub fn hb_script_from_iso15924_tag(tag: hb_tag_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_from_string(str: *const ::std::os::raw::c_char,
                                 len: ::std::os::raw::c_int) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_to_iso15924_tag(script: hb_script_t) -> hb_tag_t;
}
extern "C" {
    pub fn hb_script_get_horizontal_direction(script: hb_script_t)
     -> hb_direction_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hb_user_data_key_t {
    pub unused: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hb_user_data_key_t() {
    assert_eq!(::std::mem::size_of::<hb_user_data_key_t>() , 1usize , concat !
               ( "Size of: " , stringify ! ( hb_user_data_key_t ) ));
    assert_eq! (::std::mem::align_of::<hb_user_data_key_t>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( hb_user_data_key_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_user_data_key_t ) ) . unused as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_user_data_key_t ) ,
                "::" , stringify ! ( unused ) ));
}
impl Clone for hb_user_data_key_t {
    fn clone(&self) -> Self { *self }
}
pub type hb_destroy_func_t =
    ::std::option::Option<unsafe extern "C" fn(user_data:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hb_feature_t {
    pub tag: hb_tag_t,
    pub value: u32,
    pub start: ::std::os::raw::c_uint,
    pub end: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_feature_t() {
    assert_eq!(::std::mem::size_of::<hb_feature_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( hb_feature_t ) ));
    assert_eq! (::std::mem::align_of::<hb_feature_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( hb_feature_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_feature_t ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_feature_t ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_feature_t ) ) . value as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_feature_t ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_feature_t ) ) . start as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_feature_t ) , "::" ,
                stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_feature_t ) ) . end as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_feature_t ) , "::" ,
                stringify ! ( end ) ));
}
impl Clone for hb_feature_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn hb_feature_from_string(str: *const ::std::os::raw::c_char,
                                  len: ::std::os::raw::c_int,
                                  feature: *mut hb_feature_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_feature_to_string(feature: *mut hb_feature_t,
                                buf: *mut ::std::os::raw::c_char,
                                size: ::std::os::raw::c_uint);
}
/// hb_variation_t:
///
/// Since: 1.4.2
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hb_variation_t {
    pub tag: hb_tag_t,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_hb_variation_t() {
    assert_eq!(::std::mem::size_of::<hb_variation_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( hb_variation_t ) ));
    assert_eq! (::std::mem::align_of::<hb_variation_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( hb_variation_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_variation_t ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_variation_t ) , "::"
                , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_variation_t ) ) . value as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_variation_t ) , "::"
                , stringify ! ( value ) ));
}
impl Clone for hb_variation_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn hb_variation_from_string(str: *const ::std::os::raw::c_char,
                                    len: ::std::os::raw::c_int,
                                    variation: *mut hb_variation_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_variation_to_string(variation: *mut hb_variation_t,
                                  buf: *mut ::std::os::raw::c_char,
                                  size: ::std::os::raw::c_uint);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_memory_mode_t {
    HB_MEMORY_MODE_DUPLICATE = 0,
    HB_MEMORY_MODE_READONLY = 1,
    HB_MEMORY_MODE_WRITABLE = 2,
    HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_blob_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_blob_create(data: *const ::std::os::raw::c_char,
                          length: ::std::os::raw::c_uint,
                          mode: hb_memory_mode_t,
                          user_data: *mut ::std::os::raw::c_void,
                          destroy: hb_destroy_func_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_sub_blob(parent: *mut hb_blob_t,
                                   offset: ::std::os::raw::c_uint,
                                   length: ::std::os::raw::c_uint)
     -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_get_empty() -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_reference(blob: *mut hb_blob_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_destroy(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_set_user_data(blob: *mut hb_blob_t,
                                 key: *mut hb_user_data_key_t,
                                 data: *mut ::std::os::raw::c_void,
                                 destroy: hb_destroy_func_t,
                                 replace: hb_bool_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_user_data(blob: *mut hb_blob_t,
                                 key: *mut hb_user_data_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_blob_make_immutable(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_is_immutable(blob: *mut hb_blob_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_length(blob: *mut hb_blob_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_blob_get_data(blob: *mut hb_blob_t,
                            length: *mut ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_blob_get_data_writable(blob: *mut hb_blob_t,
                                     length: *mut ::std::os::raw::c_uint)
     -> *mut ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_unicode_general_category_t {
    HB_UNICODE_GENERAL_CATEGORY_CONTROL = 0,
    HB_UNICODE_GENERAL_CATEGORY_FORMAT = 1,
    HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED = 2,
    HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE = 3,
    HB_UNICODE_GENERAL_CATEGORY_SURROGATE = 4,
    HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER = 5,
    HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER = 6,
    HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER = 7,
    HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER = 8,
    HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER = 9,
    HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK = 10,
    HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK = 11,
    HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK = 12,
    HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER = 13,
    HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER = 14,
    HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER = 15,
    HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION = 16,
    HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION = 17,
    HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION = 18,
    HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION = 19,
    HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION = 20,
    HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION = 21,
    HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION = 22,
    HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL = 23,
    HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL = 24,
    HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL = 25,
    HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL = 26,
    HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR = 27,
    HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR = 28,
    HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR = 29,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_unicode_combining_class_t {
    HB_UNICODE_COMBINING_CLASS_NOT_REORDERED = 0,
    HB_UNICODE_COMBINING_CLASS_OVERLAY = 1,
    HB_UNICODE_COMBINING_CLASS_NUKTA = 7,
    HB_UNICODE_COMBINING_CLASS_KANA_VOICING = 8,
    HB_UNICODE_COMBINING_CLASS_VIRAMA = 9,
    HB_UNICODE_COMBINING_CLASS_CCC10 = 10,
    HB_UNICODE_COMBINING_CLASS_CCC11 = 11,
    HB_UNICODE_COMBINING_CLASS_CCC12 = 12,
    HB_UNICODE_COMBINING_CLASS_CCC13 = 13,
    HB_UNICODE_COMBINING_CLASS_CCC14 = 14,
    HB_UNICODE_COMBINING_CLASS_CCC15 = 15,
    HB_UNICODE_COMBINING_CLASS_CCC16 = 16,
    HB_UNICODE_COMBINING_CLASS_CCC17 = 17,
    HB_UNICODE_COMBINING_CLASS_CCC18 = 18,
    HB_UNICODE_COMBINING_CLASS_CCC19 = 19,
    HB_UNICODE_COMBINING_CLASS_CCC20 = 20,
    HB_UNICODE_COMBINING_CLASS_CCC21 = 21,
    HB_UNICODE_COMBINING_CLASS_CCC22 = 22,
    HB_UNICODE_COMBINING_CLASS_CCC23 = 23,
    HB_UNICODE_COMBINING_CLASS_CCC24 = 24,
    HB_UNICODE_COMBINING_CLASS_CCC25 = 25,
    HB_UNICODE_COMBINING_CLASS_CCC26 = 26,
    HB_UNICODE_COMBINING_CLASS_CCC27 = 27,
    HB_UNICODE_COMBINING_CLASS_CCC28 = 28,
    HB_UNICODE_COMBINING_CLASS_CCC29 = 29,
    HB_UNICODE_COMBINING_CLASS_CCC30 = 30,
    HB_UNICODE_COMBINING_CLASS_CCC31 = 31,
    HB_UNICODE_COMBINING_CLASS_CCC32 = 32,
    HB_UNICODE_COMBINING_CLASS_CCC33 = 33,
    HB_UNICODE_COMBINING_CLASS_CCC34 = 34,
    HB_UNICODE_COMBINING_CLASS_CCC35 = 35,
    HB_UNICODE_COMBINING_CLASS_CCC36 = 36,
    HB_UNICODE_COMBINING_CLASS_CCC84 = 84,
    HB_UNICODE_COMBINING_CLASS_CCC91 = 91,
    HB_UNICODE_COMBINING_CLASS_CCC103 = 103,
    HB_UNICODE_COMBINING_CLASS_CCC107 = 107,
    HB_UNICODE_COMBINING_CLASS_CCC118 = 118,
    HB_UNICODE_COMBINING_CLASS_CCC122 = 122,
    HB_UNICODE_COMBINING_CLASS_CCC129 = 129,
    HB_UNICODE_COMBINING_CLASS_CCC130 = 130,
    HB_UNICODE_COMBINING_CLASS_CCC133 = 132,
    HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT = 200,
    HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW = 202,
    HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE = 214,
    HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT = 216,
    HB_UNICODE_COMBINING_CLASS_BELOW_LEFT = 218,
    HB_UNICODE_COMBINING_CLASS_BELOW = 220,
    HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT = 222,
    HB_UNICODE_COMBINING_CLASS_LEFT = 224,
    HB_UNICODE_COMBINING_CLASS_RIGHT = 226,
    HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT = 228,
    HB_UNICODE_COMBINING_CLASS_ABOVE = 230,
    HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT = 232,
    HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW = 233,
    HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE = 234,
    HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT = 240,
    HB_UNICODE_COMBINING_CLASS_INVALID = 255,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_unicode_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_unicode_funcs_get_default() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_create(parent: *mut hb_unicode_funcs_t)
     -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_empty() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_reference(ufuncs: *mut hb_unicode_funcs_t)
     -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_destroy(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_set_user_data(ufuncs: *mut hb_unicode_funcs_t,
                                          key: *mut hb_user_data_key_t,
                                          data: *mut ::std::os::raw::c_void,
                                          destroy: hb_destroy_func_t,
                                          replace: hb_bool_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_user_data(ufuncs: *mut hb_unicode_funcs_t,
                                          key: *mut hb_user_data_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_unicode_funcs_make_immutable(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_is_immutable(ufuncs: *mut hb_unicode_funcs_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_parent(ufuncs: *mut hb_unicode_funcs_t)
     -> *mut hb_unicode_funcs_t;
}
pub type hb_unicode_combining_class_func_t =
    ::std::option::Option<unsafe extern "C" fn(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               unicode: hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_unicode_combining_class_t>;
pub type hb_unicode_eastasian_width_func_t =
    ::std::option::Option<unsafe extern "C" fn(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               unicode: hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_uint>;
pub type hb_unicode_general_category_func_t =
    ::std::option::Option<unsafe extern "C" fn(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               unicode: hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_unicode_general_category_t>;
pub type hb_unicode_mirroring_func_t =
    ::std::option::Option<unsafe extern "C" fn(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               unicode: hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_codepoint_t>;
pub type hb_unicode_script_func_t =
    ::std::option::Option<unsafe extern "C" fn(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               unicode: hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_script_t>;
pub type hb_unicode_compose_func_t =
    ::std::option::Option<unsafe extern "C" fn(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               a: hb_codepoint_t,
                                               b: hb_codepoint_t,
                                               ab: *mut hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
pub type hb_unicode_decompose_func_t =
    ::std::option::Option<unsafe extern "C" fn(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               ab: hb_codepoint_t,
                                               a: *mut hb_codepoint_t,
                                               b: *mut hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
/// hb_unicode_decompose_compatibility_func_t:
/// @ufuncs: a Unicode function structure
/// @u: codepoint to decompose
/// @decomposed: address of codepoint array (of length %HB_UNICODE_MAX_DECOMPOSITION_LEN) to write decomposition into
/// @user_data: user data pointer as passed to hb_unicode_funcs_set_decompose_compatibility_func()
///
/// Fully decompose @u to its Unicode compatibility decomposition. The codepoints of the decomposition will be written to @decomposed.
/// The complete length of the decomposition will be returned.
///
/// If @u has no compatibility decomposition, zero should be returned.
///
/// The Unicode standard guarantees that a buffer of length %HB_UNICODE_MAX_DECOMPOSITION_LEN codepoints will always be sufficient for any
/// compatibility decomposition plus an terminating value of 0.  Consequently, @decompose must be allocated by the caller to be at least this length.  Implementations
/// of this function type must ensure that they do not write past the provided array.
///
/// Return value: number of codepoints in the full compatibility decomposition of @u, or 0 if no decomposition available.
pub type hb_unicode_decompose_compatibility_func_t =
    ::std::option::Option<unsafe extern "C" fn(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               u: hb_codepoint_t,
                                               decomposed:
                                                   *mut hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_uint>;
extern "C" {
    /// hb_unicode_funcs_set_combining_class_func:
/// @ufuncs: a Unicode function structure
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_unicode_funcs_set_combining_class_func(ufuncs:
                                                         *mut hb_unicode_funcs_t,
                                                     func:
                                                         hb_unicode_combining_class_func_t,
                                                     user_data:
                                                         *mut ::std::os::raw::c_void,
                                                     destroy:
                                                         hb_destroy_func_t);
}
extern "C" {
    /// hb_unicode_funcs_set_eastasian_width_func:
/// @ufuncs: a Unicode function structure
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_unicode_funcs_set_eastasian_width_func(ufuncs:
                                                         *mut hb_unicode_funcs_t,
                                                     func:
                                                         hb_unicode_eastasian_width_func_t,
                                                     user_data:
                                                         *mut ::std::os::raw::c_void,
                                                     destroy:
                                                         hb_destroy_func_t);
}
extern "C" {
    /// hb_unicode_funcs_set_general_category_func:
/// @ufuncs: a Unicode function structure
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_unicode_funcs_set_general_category_func(ufuncs:
                                                          *mut hb_unicode_funcs_t,
                                                      func:
                                                          hb_unicode_general_category_func_t,
                                                      user_data:
                                                          *mut ::std::os::raw::c_void,
                                                      destroy:
                                                          hb_destroy_func_t);
}
extern "C" {
    /// hb_unicode_funcs_set_mirroring_func:
/// @ufuncs: a Unicode function structure
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_unicode_funcs_set_mirroring_func(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               func:
                                                   hb_unicode_mirroring_func_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_unicode_funcs_set_script_func:
/// @ufuncs: a Unicode function structure
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_unicode_funcs_set_script_func(ufuncs: *mut hb_unicode_funcs_t,
                                            func: hb_unicode_script_func_t,
                                            user_data:
                                                *mut ::std::os::raw::c_void,
                                            destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_unicode_funcs_set_compose_func:
/// @ufuncs: a Unicode function structure
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_unicode_funcs_set_compose_func(ufuncs: *mut hb_unicode_funcs_t,
                                             func: hb_unicode_compose_func_t,
                                             user_data:
                                                 *mut ::std::os::raw::c_void,
                                             destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_unicode_funcs_set_decompose_func:
/// @ufuncs: a Unicode function structure
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_unicode_funcs_set_decompose_func(ufuncs:
                                                   *mut hb_unicode_funcs_t,
                                               func:
                                                   hb_unicode_decompose_func_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_unicode_funcs_set_decompose_compatibility_func:
/// @ufuncs: a Unicode function structure
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_unicode_funcs_set_decompose_compatibility_func(ufuncs:
                                                                 *mut hb_unicode_funcs_t,
                                                             func:
                                                                 hb_unicode_decompose_compatibility_func_t,
                                                             user_data:
                                                                 *mut ::std::os::raw::c_void,
                                                             destroy:
                                                                 hb_destroy_func_t);
}
extern "C" {
    /// hb_unicode_combining_class:
///
/// Since: 0.9.2
    pub fn hb_unicode_combining_class(ufuncs: *mut hb_unicode_funcs_t,
                                      unicode: hb_codepoint_t)
     -> hb_unicode_combining_class_t;
}
extern "C" {
    /// hb_unicode_eastasian_width:
///
/// Since: 0.9.2
    pub fn hb_unicode_eastasian_width(ufuncs: *mut hb_unicode_funcs_t,
                                      unicode: hb_codepoint_t)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /// hb_unicode_general_category:
///
/// Since: 0.9.2
    pub fn hb_unicode_general_category(ufuncs: *mut hb_unicode_funcs_t,
                                       unicode: hb_codepoint_t)
     -> hb_unicode_general_category_t;
}
extern "C" {
    /// hb_unicode_mirroring:
///
/// Since: 0.9.2
    pub fn hb_unicode_mirroring(ufuncs: *mut hb_unicode_funcs_t,
                                unicode: hb_codepoint_t) -> hb_codepoint_t;
}
extern "C" {
    /// hb_unicode_script:
///
/// Since: 0.9.2
    pub fn hb_unicode_script(ufuncs: *mut hb_unicode_funcs_t,
                             unicode: hb_codepoint_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_unicode_compose(ufuncs: *mut hb_unicode_funcs_t,
                              a: hb_codepoint_t, b: hb_codepoint_t,
                              ab: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_decompose(ufuncs: *mut hb_unicode_funcs_t,
                                ab: hb_codepoint_t, a: *mut hb_codepoint_t,
                                b: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_decompose_compatibility(ufuncs: *mut hb_unicode_funcs_t,
                                              u: hb_codepoint_t,
                                              decomposed: *mut hb_codepoint_t)
     -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_face_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_face_create(blob: *mut hb_blob_t, index: ::std::os::raw::c_uint)
     -> *mut hb_face_t;
}
pub type hb_reference_table_func_t =
    ::std::option::Option<unsafe extern "C" fn(face: *mut hb_face_t,
                                               tag: hb_tag_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut hb_blob_t>;
extern "C" {
    pub fn hb_face_create_for_tables(reference_table_func:
                                         hb_reference_table_func_t,
                                     user_data: *mut ::std::os::raw::c_void,
                                     destroy: hb_destroy_func_t)
     -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_get_empty() -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_reference(face: *mut hb_face_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_destroy(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_set_user_data(face: *mut hb_face_t,
                                 key: *mut hb_user_data_key_t,
                                 data: *mut ::std::os::raw::c_void,
                                 destroy: hb_destroy_func_t,
                                 replace: hb_bool_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_get_user_data(face: *mut hb_face_t,
                                 key: *mut hb_user_data_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_face_make_immutable(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_is_immutable(face: *mut hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_reference_table(face: *mut hb_face_t, tag: hb_tag_t)
     -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_reference_blob(face: *mut hb_face_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_set_index(face: *mut hb_face_t,
                             index: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_index(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_upem(face: *mut hb_face_t,
                            upem: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_upem(face: *mut hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_glyph_count(face: *mut hb_face_t,
                                   glyph_count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_glyph_count(face: *mut hb_face_t)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_get_table_tags(face: *mut hb_face_t,
                                  start_offset: ::std::os::raw::c_uint,
                                  table_count: *mut ::std::os::raw::c_uint,
                                  table_tags: *mut hb_tag_t)
     -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_font_funcs_create() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_get_empty() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_reference(ffuncs: *mut hb_font_funcs_t)
     -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_destroy(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_set_user_data(ffuncs: *mut hb_font_funcs_t,
                                       key: *mut hb_user_data_key_t,
                                       data: *mut ::std::os::raw::c_void,
                                       destroy: hb_destroy_func_t,
                                       replace: hb_bool_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_funcs_get_user_data(ffuncs: *mut hb_font_funcs_t,
                                       key: *mut hb_user_data_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_funcs_make_immutable(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_is_immutable(ffuncs: *mut hb_font_funcs_t)
     -> hb_bool_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hb_font_extents_t {
    pub ascender: hb_position_t,
    pub descender: hb_position_t,
    pub line_gap: hb_position_t,
    pub reserved9: hb_position_t,
    pub reserved8: hb_position_t,
    pub reserved7: hb_position_t,
    pub reserved6: hb_position_t,
    pub reserved5: hb_position_t,
    pub reserved4: hb_position_t,
    pub reserved3: hb_position_t,
    pub reserved2: hb_position_t,
    pub reserved1: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_font_extents_t() {
    assert_eq!(::std::mem::size_of::<hb_font_extents_t>() , 48usize , concat !
               ( "Size of: " , stringify ! ( hb_font_extents_t ) ));
    assert_eq! (::std::mem::align_of::<hb_font_extents_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( hb_font_extents_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . ascender as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( ascender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . descender as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( descender ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . line_gap as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( line_gap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . reserved9 as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( reserved9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . reserved8 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( reserved8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . reserved7 as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( reserved7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . reserved6 as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( reserved6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . reserved5 as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( reserved5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . reserved4 as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( reserved4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . reserved3 as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( reserved3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . reserved2 as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_font_extents_t ) ) . reserved1 as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_font_extents_t ) ,
                "::" , stringify ! ( reserved1 ) ));
}
impl Clone for hb_font_extents_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hb_glyph_extents_t {
    pub x_bearing: hb_position_t,
    pub y_bearing: hb_position_t,
    pub width: hb_position_t,
    pub height: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_extents_t() {
    assert_eq!(::std::mem::size_of::<hb_glyph_extents_t>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( hb_glyph_extents_t ) ));
    assert_eq! (::std::mem::align_of::<hb_glyph_extents_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( hb_glyph_extents_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_extents_t ) ) . x_bearing as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_extents_t ) ,
                "::" , stringify ! ( x_bearing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_extents_t ) ) . y_bearing as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_extents_t ) ,
                "::" , stringify ! ( y_bearing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_extents_t ) ) . width as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_extents_t ) ,
                "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_extents_t ) ) . height as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_extents_t ) ,
                "::" , stringify ! ( height ) ));
}
impl Clone for hb_glyph_extents_t {
    fn clone(&self) -> Self { *self }
}
pub type hb_font_get_font_extents_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               metrics:
                                                   *mut hb_font_extents_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
pub type hb_font_get_font_h_extents_func_t = hb_font_get_font_extents_func_t;
pub type hb_font_get_font_v_extents_func_t = hb_font_get_font_extents_func_t;
pub type hb_font_get_nominal_glyph_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               unicode: hb_codepoint_t,
                                               glyph: *mut hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
pub type hb_font_get_variation_glyph_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               unicode: hb_codepoint_t,
                                               variation_selector:
                                                   hb_codepoint_t,
                                               glyph: *mut hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
pub type hb_font_get_glyph_advance_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               glyph: hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_position_t>;
pub type hb_font_get_glyph_h_advance_func_t =
    hb_font_get_glyph_advance_func_t;
pub type hb_font_get_glyph_v_advance_func_t =
    hb_font_get_glyph_advance_func_t;
pub type hb_font_get_glyph_origin_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               glyph: hb_codepoint_t,
                                               x: *mut hb_position_t,
                                               y: *mut hb_position_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
pub type hb_font_get_glyph_h_origin_func_t = hb_font_get_glyph_origin_func_t;
pub type hb_font_get_glyph_v_origin_func_t = hb_font_get_glyph_origin_func_t;
pub type hb_font_get_glyph_kerning_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               first_glyph: hb_codepoint_t,
                                               second_glyph: hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_position_t>;
pub type hb_font_get_glyph_h_kerning_func_t =
    hb_font_get_glyph_kerning_func_t;
pub type hb_font_get_glyph_v_kerning_func_t =
    hb_font_get_glyph_kerning_func_t;
pub type hb_font_get_glyph_extents_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               glyph: hb_codepoint_t,
                                               extents:
                                                   *mut hb_glyph_extents_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
pub type hb_font_get_glyph_contour_point_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               glyph: hb_codepoint_t,
                                               point_index:
                                                   ::std::os::raw::c_uint,
                                               x: *mut hb_position_t,
                                               y: *mut hb_position_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
pub type hb_font_get_glyph_name_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               glyph: hb_codepoint_t,
                                               name:
                                                   *mut ::std::os::raw::c_char,
                                               size: ::std::os::raw::c_uint,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
pub type hb_font_get_glyph_from_name_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               name:
                                                   *const ::std::os::raw::c_char,
                                               len: ::std::os::raw::c_int,
                                               glyph: *mut hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
extern "C" {
    /// hb_font_funcs_set_font_h_extents_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 1.1.2
    pub fn hb_font_funcs_set_font_h_extents_func(ffuncs: *mut hb_font_funcs_t,
                                                 func:
                                                     hb_font_get_font_h_extents_func_t,
                                                 user_data:
                                                     *mut ::std::os::raw::c_void,
                                                 destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_font_v_extents_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 1.1.2
    pub fn hb_font_funcs_set_font_v_extents_func(ffuncs: *mut hb_font_funcs_t,
                                                 func:
                                                     hb_font_get_font_v_extents_func_t,
                                                 user_data:
                                                     *mut ::std::os::raw::c_void,
                                                 destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_nominal_glyph_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 1.2.3
    pub fn hb_font_funcs_set_nominal_glyph_func(ffuncs: *mut hb_font_funcs_t,
                                                func:
                                                    hb_font_get_nominal_glyph_func_t,
                                                user_data:
                                                    *mut ::std::os::raw::c_void,
                                                destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_variation_glyph_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 1.2.3
    pub fn hb_font_funcs_set_variation_glyph_func(ffuncs:
                                                      *mut hb_font_funcs_t,
                                                  func:
                                                      hb_font_get_variation_glyph_func_t,
                                                  user_data:
                                                      *mut ::std::os::raw::c_void,
                                                  destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_h_advance_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_h_advance_func(ffuncs:
                                                      *mut hb_font_funcs_t,
                                                  func:
                                                      hb_font_get_glyph_h_advance_func_t,
                                                  user_data:
                                                      *mut ::std::os::raw::c_void,
                                                  destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_v_advance_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_v_advance_func(ffuncs:
                                                      *mut hb_font_funcs_t,
                                                  func:
                                                      hb_font_get_glyph_v_advance_func_t,
                                                  user_data:
                                                      *mut ::std::os::raw::c_void,
                                                  destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_h_origin_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_h_origin_func(ffuncs: *mut hb_font_funcs_t,
                                                 func:
                                                     hb_font_get_glyph_h_origin_func_t,
                                                 user_data:
                                                     *mut ::std::os::raw::c_void,
                                                 destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_v_origin_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_v_origin_func(ffuncs: *mut hb_font_funcs_t,
                                                 func:
                                                     hb_font_get_glyph_v_origin_func_t,
                                                 user_data:
                                                     *mut ::std::os::raw::c_void,
                                                 destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_h_kerning_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_h_kerning_func(ffuncs:
                                                      *mut hb_font_funcs_t,
                                                  func:
                                                      hb_font_get_glyph_h_kerning_func_t,
                                                  user_data:
                                                      *mut ::std::os::raw::c_void,
                                                  destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_v_kerning_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_v_kerning_func(ffuncs:
                                                      *mut hb_font_funcs_t,
                                                  func:
                                                      hb_font_get_glyph_v_kerning_func_t,
                                                  user_data:
                                                      *mut ::std::os::raw::c_void,
                                                  destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_extents_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_extents_func(ffuncs: *mut hb_font_funcs_t,
                                                func:
                                                    hb_font_get_glyph_extents_func_t,
                                                user_data:
                                                    *mut ::std::os::raw::c_void,
                                                destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_contour_point_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_contour_point_func(ffuncs:
                                                          *mut hb_font_funcs_t,
                                                      func:
                                                          hb_font_get_glyph_contour_point_func_t,
                                                      user_data:
                                                          *mut ::std::os::raw::c_void,
                                                      destroy:
                                                          hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_name_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_name_func(ffuncs: *mut hb_font_funcs_t,
                                             func:
                                                 hb_font_get_glyph_name_func_t,
                                             user_data:
                                                 *mut ::std::os::raw::c_void,
                                             destroy: hb_destroy_func_t);
}
extern "C" {
    /// hb_font_funcs_set_glyph_from_name_func:
/// @ffuncs: font functions.
/// @func: (closure user_data) (destroy destroy) (scope notified):
/// @user_data:
/// @destroy:
///
///
///
/// Since: 0.9.2
    pub fn hb_font_funcs_set_glyph_from_name_func(ffuncs:
                                                      *mut hb_font_funcs_t,
                                                  func:
                                                      hb_font_get_glyph_from_name_func_t,
                                                  user_data:
                                                      *mut ::std::os::raw::c_void,
                                                  destroy: hb_destroy_func_t);
}
extern "C" {
    pub fn hb_font_get_h_extents(font: *mut hb_font_t,
                                 extents: *mut hb_font_extents_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_v_extents(font: *mut hb_font_t,
                                 extents: *mut hb_font_extents_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_nominal_glyph(font: *mut hb_font_t,
                                     unicode: hb_codepoint_t,
                                     glyph: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_variation_glyph(font: *mut hb_font_t,
                                       unicode: hb_codepoint_t,
                                       variation_selector: hb_codepoint_t,
                                       glyph: *mut hb_codepoint_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_advance(font: *mut hb_font_t,
                                       glyph: hb_codepoint_t)
     -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_advance(font: *mut hb_font_t,
                                       glyph: hb_codepoint_t)
     -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_origin(font: *mut hb_font_t,
                                      glyph: hb_codepoint_t,
                                      x: *mut hb_position_t,
                                      y: *mut hb_position_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_origin(font: *mut hb_font_t,
                                      glyph: hb_codepoint_t,
                                      x: *mut hb_position_t,
                                      y: *mut hb_position_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_kerning(font: *mut hb_font_t,
                                       left_glyph: hb_codepoint_t,
                                       right_glyph: hb_codepoint_t)
     -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_kerning(font: *mut hb_font_t,
                                       top_glyph: hb_codepoint_t,
                                       bottom_glyph: hb_codepoint_t)
     -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_extents(font: *mut hb_font_t,
                                     glyph: hb_codepoint_t,
                                     extents: *mut hb_glyph_extents_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point(font: *mut hb_font_t,
                                           glyph: hb_codepoint_t,
                                           point_index:
                                               ::std::os::raw::c_uint,
                                           x: *mut hb_position_t,
                                           y: *mut hb_position_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_name(font: *mut hb_font_t, glyph: hb_codepoint_t,
                                  name: *mut ::std::os::raw::c_char,
                                  size: ::std::os::raw::c_uint) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_from_name(font: *mut hb_font_t,
                                       name: *const ::std::os::raw::c_char,
                                       len: ::std::os::raw::c_int,
                                       glyph: *mut hb_codepoint_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph(font: *mut hb_font_t, unicode: hb_codepoint_t,
                             variation_selector: hb_codepoint_t,
                             glyph: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_extents_for_direction(font: *mut hb_font_t,
                                             direction: hb_direction_t,
                                             extents: *mut hb_font_extents_t);
}
extern "C" {
    pub fn hb_font_get_glyph_advance_for_direction(font: *mut hb_font_t,
                                                   glyph: hb_codepoint_t,
                                                   direction: hb_direction_t,
                                                   x: *mut hb_position_t,
                                                   y: *mut hb_position_t);
}
extern "C" {
    pub fn hb_font_get_glyph_origin_for_direction(font: *mut hb_font_t,
                                                  glyph: hb_codepoint_t,
                                                  direction: hb_direction_t,
                                                  x: *mut hb_position_t,
                                                  y: *mut hb_position_t);
}
extern "C" {
    pub fn hb_font_add_glyph_origin_for_direction(font: *mut hb_font_t,
                                                  glyph: hb_codepoint_t,
                                                  direction: hb_direction_t,
                                                  x: *mut hb_position_t,
                                                  y: *mut hb_position_t);
}
extern "C" {
    pub fn hb_font_subtract_glyph_origin_for_direction(font: *mut hb_font_t,
                                                       glyph: hb_codepoint_t,
                                                       direction:
                                                           hb_direction_t,
                                                       x: *mut hb_position_t,
                                                       y: *mut hb_position_t);
}
extern "C" {
    pub fn hb_font_get_glyph_kerning_for_direction(font: *mut hb_font_t,
                                                   first_glyph:
                                                       hb_codepoint_t,
                                                   second_glyph:
                                                       hb_codepoint_t,
                                                   direction: hb_direction_t,
                                                   x: *mut hb_position_t,
                                                   y: *mut hb_position_t);
}
extern "C" {
    pub fn hb_font_get_glyph_extents_for_origin(font: *mut hb_font_t,
                                                glyph: hb_codepoint_t,
                                                direction: hb_direction_t,
                                                extents:
                                                    *mut hb_glyph_extents_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point_for_origin(font: *mut hb_font_t,
                                                      glyph: hb_codepoint_t,
                                                      point_index:
                                                          ::std::os::raw::c_uint,
                                                      direction:
                                                          hb_direction_t,
                                                      x: *mut hb_position_t,
                                                      y: *mut hb_position_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_glyph_to_string(font: *mut hb_font_t,
                                   glyph: hb_codepoint_t,
                                   s: *mut ::std::os::raw::c_char,
                                   size: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_font_glyph_from_string(font: *mut hb_font_t,
                                     s: *const ::std::os::raw::c_char,
                                     len: ::std::os::raw::c_int,
                                     glyph: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_create(face: *mut hb_face_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_create_sub_font(parent: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_get_empty() -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_reference(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_destroy(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_set_user_data(font: *mut hb_font_t,
                                 key: *mut hb_user_data_key_t,
                                 data: *mut ::std::os::raw::c_void,
                                 destroy: hb_destroy_func_t,
                                 replace: hb_bool_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_user_data(font: *mut hb_font_t,
                                 key: *mut hb_user_data_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_make_immutable(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_is_immutable(font: *mut hb_font_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_set_parent(font: *mut hb_font_t, parent: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_get_parent(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_set_face(font: *mut hb_font_t, face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_font_get_face(font: *mut hb_font_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_font_set_funcs(font: *mut hb_font_t,
                             klass: *mut hb_font_funcs_t,
                             font_data: *mut ::std::os::raw::c_void,
                             destroy: hb_destroy_func_t);
}
extern "C" {
    pub fn hb_font_set_funcs_data(font: *mut hb_font_t,
                                  font_data: *mut ::std::os::raw::c_void,
                                  destroy: hb_destroy_func_t);
}
extern "C" {
    pub fn hb_font_set_scale(font: *mut hb_font_t,
                             x_scale: ::std::os::raw::c_int,
                             y_scale: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hb_font_get_scale(font: *mut hb_font_t,
                             x_scale: *mut ::std::os::raw::c_int,
                             y_scale: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn hb_font_set_ppem(font: *mut hb_font_t,
                            x_ppem: ::std::os::raw::c_uint,
                            y_ppem: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_font_get_ppem(font: *mut hb_font_t,
                            x_ppem: *mut ::std::os::raw::c_uint,
                            y_ppem: *mut ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_font_set_ptem(font: *mut hb_font_t, ptem: f32);
}
extern "C" {
    pub fn hb_font_get_ptem(font: *mut hb_font_t) -> f32;
}
extern "C" {
    pub fn hb_font_set_variations(font: *mut hb_font_t,
                                  variations: *const hb_variation_t,
                                  variations_length: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_font_set_var_coords_design(font: *mut hb_font_t,
                                         coords: *const f32,
                                         coords_length:
                                             ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_font_set_var_coords_normalized(font: *mut hb_font_t,
                                             coords:
                                                 *const ::std::os::raw::c_int,
                                             coords_length:
                                                 ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_font_get_var_coords_normalized(font: *mut hb_font_t,
                                             length:
                                                 *mut ::std::os::raw::c_uint)
     -> *const ::std::os::raw::c_int;
}
/// hb_glyph_info_t:
/// @codepoint: either a Unicode code point (before shaping) or a glyph index
/// (after shaping).
/// @mask:
/// @cluster: the index of the character in the original text that corresponds
/// to this #hb_glyph_info_t, or whatever the client passes to
/// hb_buffer_add(). More than one #hb_glyph_info_t can have the same
/// @cluster value, if they resulted from the same character (e.g. one
/// to many glyph substitution), and when more than one character gets
/// merged in the same glyph (e.g. many to one glyph substitution) the
/// #hb_glyph_info_t will have the smallest cluster value of them.
/// By default some characters are merged into the same cluster
/// (e.g. combining marks have the same cluster as their bases)
/// even if they are separate glyphs, hb_buffer_set_cluster_level()
/// allow selecting more fine-grained cluster handling.
///
/// The #hb_glyph_info_t is the structure that holds information about the
/// glyphs and their relation to input text.
///
#[repr(C)]
#[derive(Copy)]
pub struct hb_glyph_info_t {
    pub codepoint: hb_codepoint_t,
    pub mask: hb_mask_t,
    pub cluster: u32,
    pub var1: hb_var_int_t,
    pub var2: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_info_t() {
    assert_eq!(::std::mem::size_of::<hb_glyph_info_t>() , 20usize , concat ! (
               "Size of: " , stringify ! ( hb_glyph_info_t ) ));
    assert_eq! (::std::mem::align_of::<hb_glyph_info_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( hb_glyph_info_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_info_t ) ) . codepoint as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_info_t ) ,
                "::" , stringify ! ( codepoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_info_t ) ) . mask as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_info_t ) ,
                "::" , stringify ! ( mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_info_t ) ) . cluster as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_info_t ) ,
                "::" , stringify ! ( cluster ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_info_t ) ) . var1 as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_info_t ) ,
                "::" , stringify ! ( var1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_info_t ) ) . var2 as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_info_t ) ,
                "::" , stringify ! ( var2 ) ));
}
impl Clone for hb_glyph_info_t {
    fn clone(&self) -> Self { *self }
}
pub const hb_glyph_flags_t_HB_GLYPH_FLAG_DEFINED: hb_glyph_flags_t =
    hb_glyph_flags_t::HB_GLYPH_FLAG_UNSAFE_TO_BREAK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_glyph_flags_t { HB_GLYPH_FLAG_UNSAFE_TO_BREAK = 1, }
extern "C" {
    pub fn hb_glyph_info_get_glyph_flags(info: *const hb_glyph_info_t)
     -> hb_glyph_flags_t;
}
/// hb_glyph_position_t:
/// @x_advance: how much the line advances after drawing this glyph when setting
/// text in horizontal direction.
/// @y_advance: how much the line advances after drawing this glyph when setting
/// text in vertical direction.
/// @x_offset: how much the glyph moves on the X-axis before drawing it, this
/// should not affect how much the line advances.
/// @y_offset: how much the glyph moves on the Y-axis before drawing it, this
/// should not affect how much the line advances.
///
/// The #hb_glyph_position_t is the structure that holds the positions of the
/// glyph in both horizontal and vertical directions. All positions in
/// #hb_glyph_position_t are relative to the current point.
///
#[repr(C)]
#[derive(Copy)]
pub struct hb_glyph_position_t {
    pub x_advance: hb_position_t,
    pub y_advance: hb_position_t,
    pub x_offset: hb_position_t,
    pub y_offset: hb_position_t,
    pub var: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_position_t() {
    assert_eq!(::std::mem::size_of::<hb_glyph_position_t>() , 20usize , concat
               ! ( "Size of: " , stringify ! ( hb_glyph_position_t ) ));
    assert_eq! (::std::mem::align_of::<hb_glyph_position_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( hb_glyph_position_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_position_t ) ) . x_advance as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_position_t ) ,
                "::" , stringify ! ( x_advance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_position_t ) ) . y_advance as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_position_t ) ,
                "::" , stringify ! ( y_advance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_position_t ) ) . x_offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_position_t ) ,
                "::" , stringify ! ( x_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_position_t ) ) . y_offset as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_position_t ) ,
                "::" , stringify ! ( y_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_glyph_position_t ) ) . var as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_glyph_position_t ) ,
                "::" , stringify ! ( var ) ));
}
impl Clone for hb_glyph_position_t {
    fn clone(&self) -> Self { *self }
}
/// hb_segment_properties_t:
/// @direction: the #hb_direction_t of the buffer, see hb_buffer_set_direction().
/// @script: the #hb_script_t of the buffer, see hb_buffer_set_script().
/// @language: the #hb_language_t of the buffer, see hb_buffer_set_language().
///
/// The structure that holds various text properties of an #hb_buffer_t. Can be
/// set and retrieved using hb_buffer_set_segment_properties() and
/// hb_buffer_get_segment_properties(), respectively.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct hb_segment_properties_t {
    pub direction: hb_direction_t,
    pub script: hb_script_t,
    pub language: hb_language_t,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_hb_segment_properties_t() {
    assert_eq!(::std::mem::size_of::<hb_segment_properties_t>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( hb_segment_properties_t ) ));
    assert_eq! (::std::mem::align_of::<hb_segment_properties_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( hb_segment_properties_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_segment_properties_t ) ) . direction
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_segment_properties_t
                ) , "::" , stringify ! ( direction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_segment_properties_t ) ) . script as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_segment_properties_t
                ) , "::" , stringify ! ( script ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_segment_properties_t ) ) . language as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_segment_properties_t
                ) , "::" , stringify ! ( language ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_segment_properties_t ) ) . reserved1
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_segment_properties_t
                ) , "::" , stringify ! ( reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const hb_segment_properties_t ) ) . reserved2
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( hb_segment_properties_t
                ) , "::" , stringify ! ( reserved2 ) ));
}
impl Clone for hb_segment_properties_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn hb_segment_properties_equal(a: *const hb_segment_properties_t,
                                       b: *const hb_segment_properties_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_segment_properties_hash(p: *const hb_segment_properties_t)
     -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_buffer_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_buffer_create() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_get_empty() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_reference(buffer: *mut hb_buffer_t) -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_destroy(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_set_user_data(buffer: *mut hb_buffer_t,
                                   key: *mut hb_user_data_key_t,
                                   data: *mut ::std::os::raw::c_void,
                                   destroy: hb_destroy_func_t,
                                   replace: hb_bool_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_user_data(buffer: *mut hb_buffer_t,
                                   key: *mut hb_user_data_key_t)
     -> *mut ::std::os::raw::c_void;
}
#[repr(u32)]
/// hb_buffer_content_type_t:
/// @HB_BUFFER_CONTENT_TYPE_INVALID: Initial value for new buffer.
/// @HB_BUFFER_CONTENT_TYPE_UNICODE: The buffer contains input characters (before shaping).
/// @HB_BUFFER_CONTENT_TYPE_GLYPHS: The buffer contains output glyphs (after shaping).
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_buffer_content_type_t {
    HB_BUFFER_CONTENT_TYPE_INVALID = 0,
    HB_BUFFER_CONTENT_TYPE_UNICODE = 1,
    HB_BUFFER_CONTENT_TYPE_GLYPHS = 2,
}
extern "C" {
    pub fn hb_buffer_set_content_type(buffer: *mut hb_buffer_t,
                                      content_type: hb_buffer_content_type_t);
}
extern "C" {
    pub fn hb_buffer_get_content_type(buffer: *mut hb_buffer_t)
     -> hb_buffer_content_type_t;
}
extern "C" {
    pub fn hb_buffer_set_unicode_funcs(buffer: *mut hb_buffer_t,
                                       unicode_funcs:
                                           *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_buffer_get_unicode_funcs(buffer: *mut hb_buffer_t)
     -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_buffer_set_direction(buffer: *mut hb_buffer_t,
                                   direction: hb_direction_t);
}
extern "C" {
    pub fn hb_buffer_get_direction(buffer: *mut hb_buffer_t)
     -> hb_direction_t;
}
extern "C" {
    pub fn hb_buffer_set_script(buffer: *mut hb_buffer_t,
                                script: hb_script_t);
}
extern "C" {
    pub fn hb_buffer_get_script(buffer: *mut hb_buffer_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_buffer_set_language(buffer: *mut hb_buffer_t,
                                  language: hb_language_t);
}
extern "C" {
    pub fn hb_buffer_get_language(buffer: *mut hb_buffer_t) -> hb_language_t;
}
extern "C" {
    pub fn hb_buffer_set_segment_properties(buffer: *mut hb_buffer_t,
                                            props:
                                                *const hb_segment_properties_t);
}
extern "C" {
    pub fn hb_buffer_get_segment_properties(buffer: *mut hb_buffer_t,
                                            props:
                                                *mut hb_segment_properties_t);
}
extern "C" {
    pub fn hb_buffer_guess_segment_properties(buffer: *mut hb_buffer_t);
}
#[repr(u32)]
/// hb_buffer_flags_t:
/// @HB_BUFFER_FLAG_DEFAULT: the default buffer flag.
/// @HB_BUFFER_FLAG_BOT: flag indicating that special handling of the beginning
/// of text paragraph can be applied to this buffer. Should usually
/// be set, unless you are passing to the buffer only part
/// of the text without the full context.
/// @HB_BUFFER_FLAG_EOT: flag indicating that special handling of the end of text
/// paragraph can be applied to this buffer, similar to
/// @HB_BUFFER_FLAG_EOT.
/// @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES:
/// flag indication that character with Default_Ignorable
/// Unicode property should use the corresponding glyph
/// from the font, instead of hiding them (currently done
/// by replacing them with the space glyph and zeroing the
/// advance width.)
///
/// Since: 0.9.20
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_buffer_flags_t {
    HB_BUFFER_FLAG_DEFAULT = 0,
    HB_BUFFER_FLAG_BOT = 1,
    HB_BUFFER_FLAG_EOT = 2,
    HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES = 4,
}
extern "C" {
    pub fn hb_buffer_set_flags(buffer: *mut hb_buffer_t,
                               flags: hb_buffer_flags_t);
}
extern "C" {
    pub fn hb_buffer_get_flags(buffer: *mut hb_buffer_t) -> hb_buffer_flags_t;
}
pub const hb_buffer_cluster_level_t_HB_BUFFER_CLUSTER_LEVEL_DEFAULT:
          hb_buffer_cluster_level_t =
    hb_buffer_cluster_level_t::HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_buffer_cluster_level_t {
    HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES = 0,
    HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS = 1,
    HB_BUFFER_CLUSTER_LEVEL_CHARACTERS = 2,
}
extern "C" {
    pub fn hb_buffer_set_cluster_level(buffer: *mut hb_buffer_t,
                                       cluster_level:
                                           hb_buffer_cluster_level_t);
}
extern "C" {
    pub fn hb_buffer_get_cluster_level(buffer: *mut hb_buffer_t)
     -> hb_buffer_cluster_level_t;
}
extern "C" {
    pub fn hb_buffer_set_replacement_codepoint(buffer: *mut hb_buffer_t,
                                               replacement: hb_codepoint_t);
}
extern "C" {
    pub fn hb_buffer_get_replacement_codepoint(buffer: *mut hb_buffer_t)
     -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_reset(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_clear_contents(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_pre_allocate(buffer: *mut hb_buffer_t,
                                  size: ::std::os::raw::c_uint) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_allocation_successful(buffer: *mut hb_buffer_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_reverse(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_reverse_range(buffer: *mut hb_buffer_t,
                                   start: ::std::os::raw::c_uint,
                                   end: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_buffer_reverse_clusters(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_add(buffer: *mut hb_buffer_t, codepoint: hb_codepoint_t,
                         cluster: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_buffer_add_utf8(buffer: *mut hb_buffer_t,
                              text: *const ::std::os::raw::c_char,
                              text_length: ::std::os::raw::c_int,
                              item_offset: ::std::os::raw::c_uint,
                              item_length: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hb_buffer_add_utf16(buffer: *mut hb_buffer_t, text: *const u16,
                               text_length: ::std::os::raw::c_int,
                               item_offset: ::std::os::raw::c_uint,
                               item_length: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hb_buffer_add_utf32(buffer: *mut hb_buffer_t, text: *const u32,
                               text_length: ::std::os::raw::c_int,
                               item_offset: ::std::os::raw::c_uint,
                               item_length: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hb_buffer_add_latin1(buffer: *mut hb_buffer_t, text: *const u8,
                                text_length: ::std::os::raw::c_int,
                                item_offset: ::std::os::raw::c_uint,
                                item_length: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hb_buffer_add_codepoints(buffer: *mut hb_buffer_t,
                                    text: *const hb_codepoint_t,
                                    text_length: ::std::os::raw::c_int,
                                    item_offset: ::std::os::raw::c_uint,
                                    item_length: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hb_buffer_append(buffer: *mut hb_buffer_t,
                            source: *mut hb_buffer_t,
                            start: ::std::os::raw::c_uint,
                            end: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_buffer_set_length(buffer: *mut hb_buffer_t,
                                length: ::std::os::raw::c_uint) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_length(buffer: *mut hb_buffer_t)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_get_glyph_infos(buffer: *mut hb_buffer_t,
                                     length: *mut ::std::os::raw::c_uint)
     -> *mut hb_glyph_info_t;
}
extern "C" {
    pub fn hb_buffer_get_glyph_positions(buffer: *mut hb_buffer_t,
                                         length: *mut ::std::os::raw::c_uint)
     -> *mut hb_glyph_position_t;
}
extern "C" {
    pub fn hb_buffer_normalize_glyphs(buffer: *mut hb_buffer_t);
}
#[repr(u32)]
/// hb_buffer_serialize_flags_t:
/// @HB_BUFFER_SERIALIZE_FLAG_DEFAULT: serialize glyph names, clusters and positions.
/// @HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: do not serialize glyph cluster.
/// @HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: do not serialize glyph position information.
/// @HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: do no serialize glyph name.
/// @HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: serialize glyph extents.
///
/// Flags that control what glyph information are serialized in hb_buffer_serialize_glyphs().
///
/// Since: 0.9.20
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_buffer_serialize_flags_t {
    HB_BUFFER_SERIALIZE_FLAG_DEFAULT = 0,
    HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS = 1,
    HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS = 2,
    HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES = 4,
    HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS = 8,
    HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS = 16,
}
#[repr(u32)]
/// hb_buffer_serialize_format_t:
/// @HB_BUFFER_SERIALIZE_FORMAT_TEXT: a human-readable, plain text format.
/// @HB_BUFFER_SERIALIZE_FORMAT_JSON: a machine-readable JSON format.
/// @HB_BUFFER_SERIALIZE_FORMAT_INVALID: invalid format.
///
/// The buffer serialization and de-serialization format used in
/// hb_buffer_serialize_glyphs() and hb_buffer_deserialize_glyphs().
///
/// Since: 0.9.2
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_buffer_serialize_format_t {
    HB_BUFFER_SERIALIZE_FORMAT_TEXT = 1413830740,
    HB_BUFFER_SERIALIZE_FORMAT_JSON = 1246973774,
    HB_BUFFER_SERIALIZE_FORMAT_INVALID = 0,
}
extern "C" {
    pub fn hb_buffer_serialize_format_from_string(str:
                                                      *const ::std::os::raw::c_char,
                                                  len: ::std::os::raw::c_int)
     -> hb_buffer_serialize_format_t;
}
extern "C" {
    pub fn hb_buffer_serialize_format_to_string(format:
                                                    hb_buffer_serialize_format_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_list_formats()
     -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_glyphs(buffer: *mut hb_buffer_t,
                                      start: ::std::os::raw::c_uint,
                                      end: ::std::os::raw::c_uint,
                                      buf: *mut ::std::os::raw::c_char,
                                      buf_size: ::std::os::raw::c_uint,
                                      buf_consumed:
                                          *mut ::std::os::raw::c_uint,
                                      font: *mut hb_font_t,
                                      format: hb_buffer_serialize_format_t,
                                      flags: hb_buffer_serialize_flags_t)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_deserialize_glyphs(buffer: *mut hb_buffer_t,
                                        buf: *const ::std::os::raw::c_char,
                                        buf_len: ::std::os::raw::c_int,
                                        end_ptr:
                                            *mut *const ::std::os::raw::c_char,
                                        font: *mut hb_font_t,
                                        format: hb_buffer_serialize_format_t)
     -> hb_bool_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum hb_buffer_diff_flags_t {
    HB_BUFFER_DIFF_FLAG_EQUAL = 0,
    HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH = 1,
    HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH = 2,
    HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT = 4,
    HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT = 8,
    HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH = 16,
    HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH = 32,
    HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH = 64,
    HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH = 128,
}
extern "C" {
    pub fn hb_buffer_diff(buffer: *mut hb_buffer_t,
                          reference: *mut hb_buffer_t,
                          dottedcircle_glyph: hb_codepoint_t,
                          position_fuzz: ::std::os::raw::c_uint)
     -> hb_buffer_diff_flags_t;
}
pub type hb_buffer_message_func_t =
    ::std::option::Option<unsafe extern "C" fn(buffer: *mut hb_buffer_t,
                                               font: *mut hb_font_t,
                                               message:
                                                   *const ::std::os::raw::c_char,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
extern "C" {
    pub fn hb_buffer_set_message_func(buffer: *mut hb_buffer_t,
                                      func: hb_buffer_message_func_t,
                                      user_data: *mut ::std::os::raw::c_void,
                                      destroy: hb_destroy_func_t);
}
pub type hb_font_get_glyph_func_t =
    ::std::option::Option<unsafe extern "C" fn(font: *mut hb_font_t,
                                               font_data:
                                                   *mut ::std::os::raw::c_void,
                                               unicode: hb_codepoint_t,
                                               variation_selector:
                                                   hb_codepoint_t,
                                               glyph: *mut hb_codepoint_t,
                                               user_data:
                                                   *mut ::std::os::raw::c_void)
                              -> hb_bool_t>;
extern "C" {
    pub fn hb_font_funcs_set_glyph_func(ffuncs: *mut hb_font_funcs_t,
                                        func: hb_font_get_glyph_func_t,
                                        user_data:
                                            *mut ::std::os::raw::c_void,
                                        destroy: hb_destroy_func_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_set_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_set_create() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_get_empty() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_reference(set: *mut hb_set_t) -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_destroy(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_set_user_data(set: *mut hb_set_t,
                                key: *mut hb_user_data_key_t,
                                data: *mut ::std::os::raw::c_void,
                                destroy: hb_destroy_func_t,
                                replace: hb_bool_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_get_user_data(set: *mut hb_set_t,
                                key: *mut hb_user_data_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_set_allocation_successful(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_clear(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_is_empty(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_has(set: *const hb_set_t, codepoint: hb_codepoint_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_add(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_add_range(set: *mut hb_set_t, first: hb_codepoint_t,
                            last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_del(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_del_range(set: *mut hb_set_t, first: hb_codepoint_t,
                            last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_is_equal(set: *const hb_set_t, other: *const hb_set_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_set(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_union(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_intersect(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_subtract(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_symmetric_difference(set: *mut hb_set_t,
                                       other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_invert(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_get_population(set: *const hb_set_t)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_set_get_min(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_get_max(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_next(set: *const hb_set_t, codepoint: *mut hb_codepoint_t)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_next_range(set: *const hb_set_t, first: *mut hb_codepoint_t,
                             last: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape(font: *mut hb_font_t, buffer: *mut hb_buffer_t,
                    features: *const hb_feature_t,
                    num_features: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_shape_full(font: *mut hb_font_t, buffer: *mut hb_buffer_t,
                         features: *const hb_feature_t,
                         num_features: ::std::os::raw::c_uint,
                         shaper_list: *const *const ::std::os::raw::c_char)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_list_shapers() -> *mut *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_shape_plan_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_shape_plan_create(face: *mut hb_face_t,
                                props: *const hb_segment_properties_t,
                                user_features: *const hb_feature_t,
                                num_user_features: ::std::os::raw::c_uint,
                                shaper_list:
                                    *const *const ::std::os::raw::c_char)
     -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached(face: *mut hb_face_t,
                                       props: *const hb_segment_properties_t,
                                       user_features: *const hb_feature_t,
                                       num_user_features:
                                           ::std::os::raw::c_uint,
                                       shaper_list:
                                           *const *const ::std::os::raw::c_char)
     -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create2(face: *mut hb_face_t,
                                 props: *const hb_segment_properties_t,
                                 user_features: *const hb_feature_t,
                                 num_user_features: ::std::os::raw::c_uint,
                                 coords: *const ::std::os::raw::c_int,
                                 num_coords: ::std::os::raw::c_uint,
                                 shaper_list:
                                     *const *const ::std::os::raw::c_char)
     -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached2(face: *mut hb_face_t,
                                        props: *const hb_segment_properties_t,
                                        user_features: *const hb_feature_t,
                                        num_user_features:
                                            ::std::os::raw::c_uint,
                                        coords: *const ::std::os::raw::c_int,
                                        num_coords: ::std::os::raw::c_uint,
                                        shaper_list:
                                            *const *const ::std::os::raw::c_char)
     -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_get_empty() -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_reference(shape_plan: *mut hb_shape_plan_t)
     -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_destroy(shape_plan: *mut hb_shape_plan_t);
}
extern "C" {
    pub fn hb_shape_plan_set_user_data(shape_plan: *mut hb_shape_plan_t,
                                       key: *mut hb_user_data_key_t,
                                       data: *mut ::std::os::raw::c_void,
                                       destroy: hb_destroy_func_t,
                                       replace: hb_bool_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_user_data(shape_plan: *mut hb_shape_plan_t,
                                       key: *mut hb_user_data_key_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_shape_plan_execute(shape_plan: *mut hb_shape_plan_t,
                                 font: *mut hb_font_t,
                                 buffer: *mut hb_buffer_t,
                                 features: *const hb_feature_t,
                                 num_features: ::std::os::raw::c_uint)
     -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_shaper(shape_plan: *mut hb_shape_plan_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_version(major: *mut ::std::os::raw::c_uint,
                      minor: *mut ::std::os::raw::c_uint,
                      micro: *mut ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_version_atleast(major: ::std::os::raw::c_uint,
                              minor: ::std::os::raw::c_uint,
                              micro: ::std::os::raw::c_uint) -> hb_bool_t;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
